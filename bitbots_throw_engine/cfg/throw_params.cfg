#! /usr/bin/env python

PACKAGE = 'bitbots_throw'
import roslib

roslib.load_manifest(PACKAGE)

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()
beziercurve_throw = gen.add_group("beziercurve throw", type="tab")
linear_spline_throw = gen.add_group("linear spline throw", type="tab")
cubic_spline_throw = gen.add_group("cubic spline throw", type="tab")
smooth_spline_throw = gen.add_group("smooth spline throw", type="tab")

throw_enum = gen.enum([gen.const("default", int_t, 0, "Default Throw"),
                       gen.const("beziercurve", int_t, 1, "Beziercurve Throw"),
                       gen.const("linear_spline", int_t, 2, "Linear Spline Throw"),
                       gen.const("cubic_spline", int_t, 3, "Cubic Spline Throw"),
                       gen.const("smooth_spline", int_t, 4, "Smooth Spline Throw"),
                       gen.const("testing", int_t, 5, "Throw for testing purpose")],
                      "An enum to state which throw shall be used")

#       Name       Type      Level    Description     Default Min   Max
gen.add("default_throw_enum", int_t, 0, "The throw that should used if no other throw fit via an enum", 3, min=1, max=5, edit_method=throw_enum)

# Beziercurve
beziercurve_throw.add("beziercurve_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
beziercurve_throw.add("beziercurve_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. the rule is: the throw with the lowest level will be used", 1, min=0, max=100)
beziercurve_throw.add("beziercurve_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
beziercurve_throw.add("beziercurve_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
beziercurve_throw.add("beziercurve_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=360)
beziercurve_throw.add("beziercurve_throw_enum", int_t, 0, "The throw identification enum", 1, 0, 4, edit_method=throw_enum)

# Linear Spline
linear_spline_throw.add("linear_spline_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
linear_spline_throw.add("linear_spline_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. thr rule is: the throw with the lowest level will be used", 1, min=0, max=100)
linear_spline_throw.add("linear_spline_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
linear_spline_throw.add("linear_spline_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
linear_spline_throw.add("linear_spline_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=360)
linear_spline_throw.add("linear_spline_throw_enum", int_t, 0, "The throw identification enum", 2, 0, 4, edit_method=throw_enum)

# Cubic Spline
cubic_spline_throw.add("cubic_spline_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
cubic_spline_throw.add("cubic_spline_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. thr rule is: the throw with the lowest level will be used", 1, min=0, max=100)
cubic_spline_throw.add("cubic_spline_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
cubic_spline_throw.add("cubic_spline_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
cubic_spline_throw.add("cubic_spline_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=360)
cubic_spline_throw.add("cubic_spline_throw_enum", int_t, 0, "The throw identification enum", 3, 0, 4, edit_method=throw_enum)

# Smooth Spline
smooth_spline_throw.add("smooth_spline_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
smooth_spline_throw.add("smooth_spline_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. thr rule is: the throw with the lowest level will be used", 1, min=0, max=100)
smooth_spline_throw.add("smooth_spline_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
smooth_spline_throw.add("smooth_spline_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
smooth_spline_throw.add("smooth_spline_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=360)
smooth_spline_throw.add("smooth_spline_throw_enum", int_t, 0, "The throw identification enum", 4, 0, 4, edit_method=throw_enum)

exit(gen.generate(PACKAGE, "bitbots_throw", "throw_params"))