#! /usr/bin/env python

PACKAGE = 'bitbots_throw'
import roslib

roslib.load_manifest(PACKAGE)

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()
default_throw = gen.add_group("default throw",  type="tab")
beziercurve_throw = gen.add_group("beziercurve throw",  type="tab")
linear_spline_throw = gen.add_group("linear spline throw",  type="tab")
cubic_spline_throw = gen.add_group("cubic spline throw",  type="tab")
smooth_spline_throw = gen.add_group("smooth spline throw",  type="tab")
throw_enum = gen.enum([gen.const("enum_default",       int_t, 0, "Default Throw"),
                       gen.const("enum_beziercurve",   int_t, 1, "Beziercurve Throw"),
                       gen.const("enum_linear_spline", int_t, 2, "Linear Spline Throw"),
                       gen.const("enum_cubic_spline",  int_t, 3, "Cubic Spline Throw"),
                       gen.const("enum_smooth_spline", int_t, 4, "Smooth Spline Throw")],
                      "An enum to state which throw shall be used")

#       Name       Type      Level    Description     Default Min   Max

default_throw.add("default_throw_enum", int_t, 0, "The throw that should used if no other throw fit via an enum", 4, min=1, max=4, edit_method=throw_enum)

# Beziercurve
beziercurve_throw.add("beziercurve_throw_enum", int_t, 0, "The throw identification enum", 1, 0, 4, edit_method=throw_enum)
beziercurve_throw.add("beziercurve_throw_active",   bool_t,   0, "Parameter that shows if this throw shall be used", False)
beziercurve_throw.add("beziercurve_throw_priority_level",   int_t,   0, "Parameter to control if there are two or more throws that are eligable which shall be used first. the rule is: the throw with the lowest level will be used", 1)
beziercurve_throw.add("beziercurve_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0)
beziercurve_throw.add("beziercurve_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0)
beziercurve_throw.add("beziercurve_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
beziercurve_throw.add("beziercurve_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=359)

# Linear Spline
linear_spline_throw.add("linear_spline_throw_enum", int_t, 0, "The throw identification enum", 2, 0, 4, edit_method=throw_enum)
linear_spline_throw.add("linear_spline_throw_active",   bool_t,   0, "Parameter that shows if this throw shall be used", False)
linear_spline_throw.add("linear_spline_throw_priority_level",   int_t,   0, "Parameter to control if there are two or more throws that are eligable which shall be used first. thr rule is: the throw with the lowest level will be used", 1)
linear_spline_throw.add("linear_spline_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0)
linear_spline_throw.add("linear_spline_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0)
linear_spline_throw.add("linear_spline_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
linear_spline_throw.add("linear_spline_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=359)

# Cubic Spline
cubic_spline_throw.add("cubic_spline_throw_enum", int_t, 0, "The throw identification enum", 3, 0, 4, edit_method=throw_enum)
cubic_spline_throw.add("cubic_spline_throw_active",   bool_t,   0, "Parameter that shows if this throw shall be used", False)
cubic_spline_throw.add("cubic_spline_throw_priority_level",   int_t,   0, "Parameter to control if there are two or more throws that are eligable which shall be used first. thr rule is: the throw with the lowest level will be used", 1)
cubic_spline_throw.add("cubic_spline_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0)
cubic_spline_throw.add("cubic_spline_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0)
cubic_spline_throw.add("cubic_spline_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
cubic_spline_throw.add("cubic_spline_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=359)

# Smooth Spline
smooth_spline_throw.add("smooth_spline_throw_enum", int_t, 0, "The throw identification enum", 4, 0, 4, edit_method=throw_enum)
smooth_spline_throw.add("smooth_spline_throw_active",   bool_t,   0, "Parameter that shows if this throw shall be used", False)
smooth_spline_throw.add("smooth_spline_throw_priority_level",   int_t,   0, "Parameter to control if there are two or more throws that are eligable which shall be used first. thr rule is: the throw with the lowest level will be used", 1)
smooth_spline_throw.add("smooth_spline_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0)
smooth_spline_throw.add("smooth_spline_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0)
smooth_spline_throw.add("smooth_spline_pick_up_duration_share", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_preparation_duration_share", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_duration_share", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_conclusion_duration_share", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
smooth_spline_throw.add("smooth_spline_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=359)

exit(gen.generate(PACKAGE, "bitbots_throw", "throw_params"))