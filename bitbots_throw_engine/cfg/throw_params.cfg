#! /usr/bin/env python

PACKAGE = 'bitbots_throw'
import roslib

roslib.load_manifest(PACKAGE)

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()
throw_1 = gen.add_group("Throw 1", type="tab")
throw_2 = gen.add_group("Throw 2", type="tab")
throw_3 = gen.add_group("Throw 3", type="tab")
throw_4 = gen.add_group("Throw 4", type="tab")

throw_enum = gen.enum([gen.const("default", int_t, 0, "Default Throw"),
                       gen.const("beziercurve", int_t, 1, "Beziercurve Throw"),
                       gen.const("linear_spline", int_t, 2, "Linear Spline Throw"),
                       gen.const("cubic_spline", int_t, 3, "Cubic Spline Throw"),
                       gen.const("smooth_spline", int_t, 4, "Smooth Spline Throw"),
                       gen.const("testing", int_t, 5, "Throw for testing purpose")],
                      "An enum to state which throw shall be used")

#       Name       Type      Level    Description     Default Min   Max
gen.add("default_throw_enum", int_t, 0, "The throw that should used if no other throw fit via an enum", 3, min=1, max=5, edit_method=throw_enum)

# Throw 1 (default: Beziercurve)
throw_1.add("throw_1_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
throw_1.add("throw_1_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. the rule is: the throw with the lowest level will be used", 1, min=0, max=100)
throw_1.add("throw_1_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
throw_1.add("throw_1_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=90)
throw_1.add("throw_1_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
throw_1.add("throw_1_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
throw_1.add("throw_1_movement_duration", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_1.add("throw_1_movement_share_pick_up", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_1.add("throw_1_movement_share_preparation", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_1.add("throw_1_movement_share_throw", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_1.add("throw_1_movement_share_conclusion", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_1.add("throw_1_throw_enum", int_t, 0, "The throw identification enum", 1, 0, 4, edit_method=throw_enum)

# Throw 2 (default: Linear Spline)
throw_2.add("throw_2_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
throw_2.add("throw_2_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. the rule is: the throw with the lowest level will be used", 1, min=0, max=100)
throw_2.add("throw_2_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
throw_2.add("throw_2_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
throw_2.add("throw_2_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
throw_2.add("throw_2_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=90)
throw_2.add("throw_2_movement_duration", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_2.add("throw_2_movement_share_pick_up", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_2.add("throw_2_movement_share_preparation", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_2.add("throw_2_movement_share_throw", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_2.add("throw_2_movement_share_conclusion", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_2.add("throw_2_throw_enum", int_t, 0, "The throw identification enum", 2, 0, 4, edit_method=throw_enum)

# Throw 3 (default: Cubic Spline)
throw_3.add("throw_3_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
throw_3.add("throw_3_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. the rule is: the throw with the lowest level will be used", 1, min=0, max=100)
throw_3.add("throw_3_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
throw_3.add("throw_3_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
throw_3.add("throw_3_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
throw_3.add("throw_3_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=90)
throw_3.add("throw_3_movement_duration", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_3.add("throw_3_movement_share_pick_up", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_3.add("throw_3_movement_share_preparation", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_3.add("throw_3_movement_share_throw", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_3.add("throw_3_movement_share_conclusion", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_3.add("throw_3_throw_enum", int_t, 0, "The throw identification enum", 3, 0, 4, edit_method=throw_enum)

# Throw 4 (default: Smooth Spline)
throw_4.add("throw_4_throw_active", bool_t, 0, "Parameter that shows if this throw shall be used", False)
throw_4.add("throw_4_throw_priority_level", int_t, 0, "Parameter to control if there are two or more throws that are eligable which shall be used first. the rule is: the throw with the lowest level will be used", 1, min=0, max=100)
throw_4.add("throw_4_throw_min_distance", double_t, 0, "The minimum distance this throw should be used for", 0, min=0, max=100)
throw_4.add("throw_4_throw_max_distance", double_t, 0, "The maximum distance this throw should be used for", 0, min=0, max=100)
throw_4.add("throw_4_throw_strength", double_t, 1, "How many percent of the max_throw_velocity shall be used if possible", 0, min=0, max=1)
throw_4.add("throw_4_throw_angle", double_t, 0, "The Angle at which the ball shall thrown. If value is 0, the default value will be used.", 0, min=0, max=90)
throw_4.add("throw_4_movement_duration", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_4.add("throw_4_movement_share_pick_up", double_t, 0, "The share of the movement cycle dedicated to picking up the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_4.add("throw_4_movement_share_preparation", double_t, 0, "The share of the movement cycle dedicated to prepare the throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_4.add("throw_4_movement_share_throw", double_t, 0, "The share of the movement cycle dedicated to throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_4.add("throw_4_movement_share_conclusion", double_t, 0, "The share of the movement cycle dedicated to motion after throwing the ball. If value is 0, the default value will be used.", 0, min=0, max=1)
throw_4.add("throw_4_throw_enum", int_t, 0, "The throw identification enum", 4, 0, 4, edit_method=throw_enum)

exit(gen.generate(PACKAGE, "bitbots_throw", "throw_params"))